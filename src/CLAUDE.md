# Claude Memory File

## Working Guidelines
- never unstage or undo my changes (unless explicitly asked), understand and incorporate them!

This project contains the source code for the go language and it's compiler and its toolchains.
It is very comprehensive and we need to be careful when searching for a code to not use up all our clout code subscription context window and usage.

Do NOT explore the whole codebase structure and architecture

We are trying to achieve small modifications to the compiler only and nothing else thus we only want to recompile the compiler and not the whole toolchain.

Always start simple and when the simple case works add more complexity. 

!!! Important! Never do destructive commands like remove, rm, git clean, etc without explicit user confirmation, even in YOLO mode!!!

### Style Guidelines

Always replace interface{} with any 


# Compile

To compile go, use the following command:

cd /opt/other/go/src
./make.bash >/dev/null 2>&1

or maybe
GOOS=darwin GOARCH=arm64 ./bootstrap.bash ?

So far incremental building does not work like this :(
../bin/go tool dist install -v cmd/compile


# Go Compiler Lexer/Scanner Summary

## Main Files:
- Project root folder `/opt/other/go/`
- Claude root folder `/opt/other/go/src/`
- Core lexical analysis for Go compiler
- Main files:
  - `cmd/compile/internal/syntax/scanner.go`: main scanner implementation
  - `go/scanner/scanner.go`: standard scanner used by tools like `go run`, `go build`
  - `go/scanner/tokens.go`: token definitions
  - `go/scanner/source.go`: source reading and buffering
  - ./cmd/compile/internal/noder folder with important files:
      unified.go
      lex_test.go
      lex.go
      import.go
      posmap.go
      types.go
      export.go
      quirks.go
      codes.go
      writer.go
      linker.go
      doc.go
      reader.go
      irgen.go
      helpers.go
      noder.go
- Token types defined in `tokens.go`, scanner state in scanner struct
- Character reading via `source.go` buffered reader
- Supports UTF-8, tracks line/column positions
- `next()` method: main tokenization loop with large switch statement for each character

- ### Dual Scanner System
  1. Standard Scanner (go/scanner/scanner.go) - Used by go run, go build, and other tools for initial parsing/package analysis
  2. Internal Syntax Scanner (cmd/compile/internal/syntax/scanner.go) - Used by the compiler itself for actual compilation
- Two main scanning modes: normal tokens + comment/directive callbacks

## Key Methods:
- `next()`: main tokenization (big switch ~line 110-355)
- `ident()`: identifier scanning
- `number()`: numeric literal parsing  
- `stdString()`, `rawString()`, `rune()`: string/char literals
- `lineComment()`, `fullComment()`: comment handling
- Error handling via `errorf()`, position tracking


## Implementation Order for builtins

  1. types2 declarations (universe.go)
  2. types2 handling (builtins.go)
  3. IR declarations (node.go)
  4. IR registration (typecheck/universe.go)
  5. IR handling (func.go, typecheck.go)

src/go/types/call.go
src/cmd/compile/internal/ir/node.go
src/cmd/compile/internal/typecheck/func.go
src/cmd/compile/internal/typecheck/typecheck.go
src/cmd/compile/internal/typecheck/universe.go
src/cmd/compile/internal/types2/builtins.go
src/cmd/compile/internal/types2/call.go
src/cmd/compile/internal/types2/universe.go
src/cmd/compile/internal/types2/typexpr.go

## Generated Files (DO NOT EDIT)
Never touched generated files such as
src/cmd/compile/internal/ir/op_string.go
  - *_string.go - Generated by stringer tool for enum/const string representations, e.g. token_string.go
  - *_gen.go - Generated by various code generators
  - builtin.go - Generated by mkbuiltin.go for runtime function signatures
  - rewrite*.go - Generated SSA rewrite rules
  - token_string.go - Generated token name strings
  - Files with headers like // Code generated by ... DO NOT EDIT.

Rule: If you see DO NOT EDIT in the header, never modify it directly. Find the source file/generator that creates it and modify that instead. And generate via ./make.bash

# Testing Guidelines
- recompile bin/go before testing!
- Always create exactly one new go file <git_root>/goo/test_{feature}.go to test the new feature; not src/goo, rather ../goo/ ! Don't try to create a new folder. If the folder does not exist you're trying the wrong folder: it should exist!)
- IF you end up with multiple test / debug files (which you shouldn't) make sure to delete all but one before committing
- Before committing quickly run these new tests with the freshly built ../bin/go 
- After committing, run the following command in src/ to test the compatibility with the whole system:

```bash
GOROOT=$(pwd)/.. ./run.bash --no-rebuild 2>&1 | grep -Ev '^\?|^ok ' | tee /dev/tty | grep -m1 FAIL && exit 1
```
- This command runs the tests, filters out the output to show only failures, and exits with an error code if any tests fail.
- if we encounter a FAIL, ponder whether our changes might be related to it and if so try once to fix it or tell me to look at it.

# Test Writing Memories
- Usually when you create one test there's no more need to modify it unless you really missed something

## Editing Guidelines
- never edit token_string.go
- always use ../bin/go 