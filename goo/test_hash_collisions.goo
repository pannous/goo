#!/usr/bin/env goo
package main

import (
	"fmt"
	"sort"
)

func main() {
	// All Go keywords to test
	keywords := []string{
		"break", "case", "chan", "const", "continue",
		"default", "defer", "else", "fallthrough", "for",
		"func", "go", "goto", "if", "import",
		"interface", "list", "map", "package", "range",
		"return", "select", "struct", "switch", "type", "var",
	}

	// Map to track which keywords hash to which values
	hashMap := make(map[uint][]string)
	keywordMapSize := 64

	fmt.Printf("Testing hash function with keywordMap size %d\n", keywordMapSize)
	fmt.Println("Hash function: (uint(s[0])<<4 ^ uint(s[1]) + uint(len(s))) & uint(len(keywordMap)-1)")
	fmt.Println()

	// Calculate hash for each keyword
	for _, keyword := range keywords {
		if len(keyword) < 2 {
			fmt.Printf("Warning: keyword '%s' is too short for hash function\n", keyword)
			continue
		}
		
		// Hash function: (uint(s[0])<<4 ^ uint(s[1]) + uint(len(s))) & uint(len(keywordMap)-1)
		hash := (uint(keyword[0])<<4 ^ uint(keyword[1]) + uint(len(keyword))) & uint(keywordMapSize-1)
		
		hashMap[hash] = append(hashMap[hash], keyword)
		fmt.Printf("%-12s -> hash: %2d (binary: %06b)\n", keyword, hash, hash)
	}

	fmt.Println("\n=== Collision Analysis ===")
	
	// Find and report collisions
	collisionCount := 0
	var collisionPairs []string
	
	// Sort hash values for consistent output
	var hashes []uint
	for h := range hashMap {
		hashes = append(hashes, h)
	}
	sort.Slice(hashes, func(i, j int) bool { return hashes[i] < hashes[j] })
	
	for _, hash := range hashes {
		keywords := hashMap[hash]
		if len(keywords) > 1 {
			collisionCount++
			fmt.Printf("Hash %2d: %v (COLLISION!)\n", hash, keywords)
			for i := 0; i < len(keywords); i++ {
				for j := i + 1; j < len(keywords); j++ {
					collisionPairs = append(collisionPairs, fmt.Sprintf("%s <-> %s", keywords[i], keywords[j]))
				}
			}
		}
	}

	if collisionCount == 0 {
		fmt.Println("No collisions found!")
	} else {
		fmt.Printf("\nTotal collision groups: %d\n", collisionCount)
		fmt.Println("Collision pairs:")
		for _, pair := range collisionPairs {
			fmt.Printf("  - %s\n", pair)
		}
	}

	// Analyze the hash distribution
	fmt.Printf("\n=== Hash Distribution ===\n")
	fmt.Printf("Total keywords: %d\n", len(keywords))
	fmt.Printf("Unique hash values used: %d out of %d possible\n", len(hashMap), keywordMapSize)
	fmt.Printf("Hash table utilization: %.1f%%\n", float64(len(hashMap))*100/float64(keywordMapSize))

	// Suggest fixes if there are collisions
	if collisionCount > 0 {
		fmt.Println("\n=== Suggested Fixes ===")
		fmt.Println("1. Increase keywordMap size from 64 to 128 (change mask from 63 to 127)")
		fmt.Println("2. Modify the hash function to better distribute the keywords")
		fmt.Println("3. Use a different hash function that considers more characters")
		fmt.Println("4. Add a secondary hash or use chaining for collision resolution")
		
		// Test with larger map size
		fmt.Println("\nTesting with keywordMap size 128:")
		testWithSize(keywords, 128)
	}
}

func testWithSize(keywords []string, size int) {
	hashMap := make(map[uint][]string)
	
	for _, keyword := range keywords {
		if len(keyword) < 2 {
			continue
		}
		hash := (uint(keyword[0])<<4 ^ uint(keyword[1]) + uint(len(keyword))) & uint(size-1)
		hashMap[hash] = append(hashMap[hash], keyword)
	}
	
	collisions := 0
	for _, keywords := range hashMap {
		if len(keywords) > 1 {
			collisions++
			fmt.Printf("  Collision at hash: %v\n", keywords)
		}
	}
	
	if collisions == 0 {
		fmt.Println("  No collisions with this size!")
	} else {
		fmt.Printf("  Still %d collision groups\n", collisions)
	}
}